{
  "section_index": 135,
  "section_id": "2.1",
  "title": "2.1 Memory-Based Transport Model (PCIe)",
  "level": 2,
  "pages": {
    "start": 44,
    "end": 46,
    "count": 3
  },
  "content": {
    "text": "In the memory-based model, Submission and Completion Queues are allocated in memory.\nA host creates queues, up to the maximum supported by the controller. Typically, the number of command\nqueues created is based on the system configuration and anticipated workload. For example, on a four\ncore processor based system, there may be a queue pair per core to avoid locking and ensure data\nstructures are created in the appropriate processor coreâ€™s cache. Figure 6 provides a graphical\nrepresentation of the queue pair mechanism, showing a 1:1 mapping between Submission Queues and\nCompletion Queues. Figure 7 shows an example where multiple I/O Submission Queues utilize the same\nI/O Completion Queue on Core B. Figure 6 and Figure 7 show that there is always a 1:1 mapping between\nthe Admin Submission Queue and Admin Completion Queue.\nA Submission Queue (SQ) is a circular buffer with a fixed slot size that the host uses to submit commands\nfor execution by the controller. The host updates the appropriate SQ Tail doorbell register when there are\none to n new commands to execute. The previous SQ Tail value is overwritten in the controller when there\nis a new doorbell register write. The controller fetches SQ entries in order from the Submission Queue and\nmay execute those commands in any order.\nEach submission queue entry is a command. Commands are 64 bytes in size. The physical memory\nlocations in memory to use for data transfers are specified using Physical Region Page (PRP) entries or\nScatter Gather Lists (SGL). Each command may include two PRP entries or one Scatter Gather List\nsegment. If more than two PRP entries are necessary to describe the data buffer, then a pointer to a PRP\nList that describes a list of PRP entries is provided. If more than one SGL segment is necessary to describe\nthe data buffer, then the SGL segment provides a pointer to the next SGL segment.\nA Completion Queue (CQ) is a circular buffer with a fixed slot size used to post status for completed\ncommands. A completed command is uniquely identified by a combination of the associated SQ identifier\nand command identifier that is assigned by a host. In the memory-based transport model multiple\nSubmission Queues may be associated with a single Completion Queue. A configuration with a single\nCompletion Queue may be used where a single worker thread processes all command completions via one\nCompletion Queue even when those commands originated from multiple Submission Queues. The CQ\nHead pointer is updated by a host after processing completion queue entries indicating the last free CQ\nslot. A Phase Tag (P) bit is defined in the completion queue entry to indicate whether an entry has been\nnewly posted without the host consulting a register (refer to section 4.2.4). The Phase Tag bit enables the\nhost to determine whether entries are new or not.",
    "tables": [],
    "figures": [
      {
        "id": "figure_45_115",
        "page": 45,
        "bbox": [
          115.0,
          115.0,
          881.0,
          343.0
        ],
        "title": "Figure 6: Queue Pair Example, 1:1 Mapping",
        "image_path": "Figure_2_1_Memory_Based_Transport_Model_PCIe_1.png"
      },
      {
        "id": "figure_45_389",
        "page": 45,
        "bbox": [
          115.0,
          389.0,
          883.0,
          610.0
        ],
        "title": "Figure 7: Queue Pair Example, n:1 Mapping",
        "image_path": "Figure_2_1_Memory_Based_Transport_Model_PCIe_2.png"
      }
    ]
  },
  "statistics": {
    "table_count": 0,
    "figure_count": 2
  }
}