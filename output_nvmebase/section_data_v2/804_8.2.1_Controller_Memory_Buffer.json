{
  "section_index": 804,
  "section_id": "8.2.1",
  "title": "8.2.1 Controller Memory Buffer",
  "level": 3,
  "pages": {
    "start": 682,
    "end": 684,
    "count": 3
  },
  "content": {
    "text": "The Controller Memory Buffer (CMB) is a region of general purpose read/write memory on the controller.\nThe controller indicates support for the CMB by setting CAP.CMBS to ‘1’. The host indicates intent to use\nthe CMB by setting CMBMSC.CRE to ‘1’. If this bit is set to ‘1’, the controller indicates the properties of the\nCMB via the CMBLOC and CMBSZ properties (refer to section 3.1.4).\nThe CMB may be used for a variety of purposes. The controller indicates which purposes the memory may\nbe used for by setting support flags in the CMBSZ property.\nThe CMB’s PCI Express address range is used for external memory read and write requests to the CMB.\nThe PCI Express base address of the CMB is defined by the PCI Base Address Register (BAR) indicated\nby CMBLOC.BIR, and the offset indicated by CMBLOC.OFST. The size of the CMB is indicated by\nCMBSZ.SZ.\nThe controller uses the CMB’s controller address range to reference CMB with addresses supplied by the\nhost. The PCI Express address range and the controller address range of the CMB may differ, but both\nranges have the same size, and equivalent offsets within each range have a one-to-one correspondence.\nThe host configures the controller address range via the CMBMSC property.\nThe host enables the CMB’s controller memory space via the CMBMSC.CMSE bit. When controller memory\nspace is enabled, if the host supplies an address referencing the CMB’s controller address range, then the\ncontroller directs memory read or write requests for this address to the CMB.\nWhen the CMB’s controller memory space is disabled, the controller does not consider any host-supplied\naddress to reference the CMB’s controller address range, and memory read and write requests are directed\nelsewhere (e.g., to memory other than the CMB).\nTo prevent possible misdirection of the controller’s memory requests, before the host enables the CMB’s\ncontroller memory space, the host should configure the CMB’s controller address range so that the\naddresses do not overlap any address that the host intends to use for DMA.\nIn versions prior to NVM Express Base Specification, Revision 1.4, for a controller that supports the CMB,\nthe CMB’s controller address range is fixed to be equal to its PCI Express address range, and the CMB’s\ncontroller memory space is always enabled whenever the controller is enabled. To prevent misdirection of\ncontroller memory requests when such a controller is assigned to a virtual machine, the host (on the\nhypervisor or host OS) should not enable translation of the CMB’s PCI Express address range and should\nensure that this address range does not overlap any range of pre-translated addresses that the virtual\nmachine may use for DMA.\nA host may configure the CMBMSC property so that CMB operates when the controller is assigned to a\nvirtual machine that only supports NVM Express Base Specification, Revision 1.3 and earlier. To prevent\nthat virtual machine from unintentionally clearing the CMBMSC property to 0h, the contents of the CMBMSC\nproperty are preserved across a Controller Level Reset (CLR) initiated by:\n•\na Controller Reset; and\n•\na Function Level Reset (refer to the NVMe over PCIe Transport Specification).\nSubmission Queues in host memory require the controller to perform a PCI Express read from host memory\nin order to fetch the submission queue entries. Submission Queues in controller memory enable the host\nto directly write the entire submission queue entry to the controller's internal memory space, avoiding one\nread from the controller to the host. This approach reduces latency in command execution and improves\nefficiency in a PCI Express fabric topology that may include multiple switches. Similarly, PRP Lists or SGLs\nrequire separate fetches across the PCI Express fabric, which may be avoided by writing the PRP or SGL\nto the Controller Memory Buffer. Completion Queues in the Controller Memory Buffer may be used for peer\nto peer or other applications. For writes of small amounts of data, it may be advantageous to have the host\nwrite the data and/or metadata to the Controller Memory Buffer rather than have the controller fetch it from\nhost memory.\nThe contents of the Controller Memory Buffer are undefined as the result of:\n•\nthe CMBMSC.CMSE bit transitioning from ‘0’ to ‘1’;\n•\na CLR initiated by a Controller Reset; or\n•\na Function Level Reset.\nThe host should initialize any memory in the Controller Memory Buffer before being referenced (e.g., a\nCompletion Queue shall be initialized by the host in order for the Phase Tag to be used correctly (refer to\nsection 4.2.4)).\nA CMB implementation has a maximum sustained write throughput. The CMB implementation may also\nhave an optional write elasticity buffer used to buffer writes from CMB PCIe write requests. When the CMB\nsustained write throughput is less than the PCI Express link throughput, then such a write elasticity buffer\nallows PCIe write request burst throughput to exceed the CMB sustained write throughput without back\npressuring into the PCI Express fabric.\nThe time required to transfer data from the write elasticity buffer to the CMB is the amount of data written\nto the elasticity buffer divided by the maximum CMB sustained write throughput (refer to section 3.1.4.19).\nThe time to transfer the entire contents of the write elasticity buffer is the size of the CMB elasticity buffer\n(refer to section 3.1.4.18) divided by the maximum CMB sustained write throughput. The host is required\nto account for any units differences in the CMB Elasticity Buffer Size Units field and the CMB Sustained\nWrite Throughput Units field.\nA controller memory-based queue is used in the same manner as a host memory-based queue – the\ndifference is the memory address used is located within the controller’s own memory rather than in the host\nmemory. The Admin or I/O Queues may be placed in the Controller Memory Buffer. If the\nCMBLOC.CQMMS bit (refer to Figure 47) is cleared to ‘0’, then for a particular queue, all memory\nassociated with it shall reside in either the Controller Memory Buffer or outside the Controller Memory\nBuffer.\nIf the CMBLOC.CQPDS bit (refer to Figure 47) is cleared to ‘0’, then for all queues in the Controller Memory\nBuffer, the queue shall be physically contiguous.\nThe controller may support PRP Lists and SGLs in the Controller Memory Buffer. If the CMBLOC.CDPMLS\nbit (refer to Figure 47) is cleared to ‘0’, then for a particular PRP List or SGL associated with a single\ncommand, all memory containing the PRP List or SGL shall be either entirely located in the Controller\nMemory Buffer or entirely located outside the Controller Memory Buffer.\nPRP Lists and SGLs associated with a command may be placed in the Controller Memory Buffer if that\ncommand is present in a Submission Queue in the Controller Memory Buffer. If:\na) CMBLOC.CDPCILS bit (refer to Figure 47) is cleared to ‘0’; and\nb) a command is not present in a Submission Queue in the Controller Memory Buffer,\nthen the PRP Lists and SGLs associated with that command shall not be placed in the Controller Memory\nBuffer.\nThe controller may support data and metadata in the Controller Memory Buffer. If the CMBLOC.CDMMMS\nbit (refer to Figure 47) is cleared to ‘0’, then all data and metadata, if any, associated with a particular\ncommand shall be either entirely located in the Controller Memory Buffer or entirely located outside the\nController Memory Buffer.\nIf the requirements for the Controller Memory Buffer use are violated by the host, the controller shall abort\nthe associated command with a status code of Invalid Use of Controller Memory Buffer.\nThe address region allocated for the CMB shall be 4 KiB aligned. It is recommended that a controller\nallocate the CMB on an 8 KiB boundary. The controller shall support burst transactions up to the maximum\npayload size, support byte enables, and arbitrary byte alignment. The host shall ensure that all writes to the\nCMB that are needed for a command have been sent before updating the SQ Tail doorbell property. The\nMemory Write Request to the SQ Tail doorbell property shall not have the Relaxed Ordering bit set to ‘1’\n(refer to the PCI Express Base Specification), to ensure that prior writes to the CMB have completed.",
    "tables": [],
    "figures": []
  },
  "statistics": {
    "table_count": 0,
    "figure_count": 0
  }
}