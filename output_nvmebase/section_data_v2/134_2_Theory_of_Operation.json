{
  "section_index": 134,
  "section_id": "2",
  "title": "2 Theory of Operation",
  "level": 1,
  "pages": {
    "start": 42,
    "end": 44,
    "count": 3
  },
  "content": {
    "text": "The NVM Express scalable interface is designed to address the needs of storage systems that utilize PCI\nExpress based solid state drives or fabric connected devices. The interface provides optimized command\nsubmission and completion paths. It includes support for parallel operation by supporting up to 65,535 I/O\nQueues with up to 65,535 outstanding commands per I/O Queue. Additionally, support has been added for\nmany Enterprise capabilities like end-to-end data protection (compatible with SCSI Protection Information,\ncommonly known as T10 DIF, and SNIA DIX standards), enhanced error reporting, and virtualization.\nThe interface has the following key attributes:\n•\nDoes not require uncacheable / MMIO register reads in the command submission or completion\npath;\n•\nA maximum of one MMIO register write or one 64B message is necessary in the command\nsubmission path;\n•\nSupport for up to 65,535 I/O Queues, with each I/O Queue supporting up to 65,535 outstanding\ncommands;\n•\nPriority associated with each I/O Queue with well-defined arbitration mechanism;\n•\nAll information to complete a 4 KiB read request is included in the 64B command itself, ensuring\nefficient small I/O operation;\n•\nEfficient and streamlined command set;\n•\nSupport for MSI/MSI-X and interrupt aggregation;\n•\nSupport for multiple namespaces;\n•\nEfficient support for I/O virtualization architectures like SR-IOV;\n•\nRobust error reporting and management capabilities; and\n•\nSupport for multi-path I/O and namespace sharing.\nThis specification defines a streamlined set of properties that are used to configure low level controller\nattributes and obtain low level controller status. These properties have a transport specific mechanism for\ndefining access (e.g., memory-based transports use registers, whereas message-based transports use the\nProperty Get and Property Set commands). The following are examples of functionality defined in\nproperties:\n•\nIndication of controller capabilities;\n•\nStatus for controller failures (command status is provided in a CQE);\n•\nAdmin Queue configuration (I/O Queue configuration processed via Admin commands); and\n•\nDoorbell registers (refer to the NVMe over PCIe Transport Specification) for a scalable number of\nSubmission and Completion Queues.\nThere are two defined models for communication between the host and the NVM subsystem, a memory-\nbased transport model and a message-based transport model. All NVM subsystems require the underlying\nNVMe Transport to provide reliable NVMe command and data delivery. An NVMe Transport is an abstract\nprotocol layer independent of any physical interconnect properties. A taxonomy of NVMe Transports, along\nwith examples, is shown in Figure 4. An NVMe Transport may expose a memory-based transport model or\na message-based transport model. The message-based transport model has two subtypes: the message-\nonly transport model and the message/memory transport model.\nA memory-based transport model is one in which commands, responses, and data are transferred between\na host and an NVM subsystem by performing explicit memory read and write operations (e.g., over PCIe).\nA message-based transport model is one in which messages containing command capsules and response\ncapsules are sent between a host and an NVM subsystem (e.g., over a fabric). The two subtypes of\nmessage-based transport models are differentiated by how data is sent between a host and an NVM\nsubsystem. In the message-only transport model data is only sent between a host and an NVM subsystem\nusing capsules or messages. The message/memory transport model uses a combination of messages and\nexplicit memory read and write operations to transfer command capsules, response capsules and data\nbetween a host and an NVM subsystem. Data may optionally be included in command capsules and\nresponse capsules. Both the message-only transport model and the message/memory transport model are\nreferenced as message-based transport models throughout this specification when the description is\napplicable to both subtypes.\nAn NVM subsystem is made up of a single domain or multiple domains as described in section 3.2.5. An\nNVM subsystem may optionally include a non-volatile storage medium, and an interface between the\ncontroller(s) of the NVM subsystem and the non-volatile storage medium. Controllers expose this non-\nvolatile storage medium to hosts through namespaces. An NVM subsystem is not required to have the\nsame namespaces attached to all controllers. An NVM subsystem that supports a Discovery controller does\nnot support any other controller type. A Discovery Service is an NVM subsystem that supports Discovery\ncontrollers only (refer to section 3.1).\nThe capabilities and settings that apply to an NVM Express controller are indicated in the Controller\nCapabilities (CAP) property and the Identify Controller data structure (refer to Figure 328).\nA namespace is a set of resources (e.g., formatted non-volatile storage) that may be accessed by a host.\nA namespace has an associated namespace identifier that a host uses to access that namespace. The set\nof resources may consist of non-volatile storage and/or other resources.\nAssociated with each namespace is an I/O Command Set that operates on that namespace. An NVM\nExpress controller may support multiple namespaces. Namespaces may be created and deleted using the\nNamespace Management command and Capacity Management command. The Identify Namespace data\nstructures (refer to section 1.5.50) indicate capabilities and settings that are specific to a particular\nnamespace.\nThe NVM Express interface is based on a paired Submission and Completion Queue mechanism.\nCommands are placed by a host into a Submission Queue. Completions are placed into the associated\nCompletion Queue by the controller.\nThere are three types of commands that are defined in NVM Express: Admin commands, I/O commands\nand Fabrics commands. Figure 5 shows these different command types.\nAn Admin Submission Queue and associated Completion Queue exist for the purpose of controller\nmanagement and control (e.g., creation and deletion of I/O Submission and Completion Queues, aborting\ncommands, etc.). Only commands that are part of the Admin Command Set or the Fabrics Command Set\nmay be submitted to the Admin Submission Queue.\nAn I/O Command Set is used with an I/O queue pair. This specification defines common I/O commands.\nI/O Command Sets are defined in the NVM Express I/O Command Set specifications. The example I/O\nCommand Sets shown in Figure 5 are the NVM Command Set, the Key Value Command Set, and the\nZoned Namespace Command Set. Other I/O Command Sets include the Computational Programs\nCommand Set and the SLM Command Set.\nThe Fabrics Command Set is NVMe over Fabrics specific. Fabrics Command Set commands are used for\noperations specific to NVMe over Fabrics including establishing a connection, NVMe in-band\nauthentication, and to get or set a property. All Fabrics commands may be submitted on the Admin\nSubmission Queue and some Fabrics commands may also be submitted on an I/O Submission Queue.\nUnlike Admin and I/O commands, Fabrics commands are processed by a controller regardless of whether\nthe controller is enabled (i.e., regardless of the state of CC.EN).",
    "tables": [],
    "figures": []
  },
  "statistics": {
    "table_count": 0,
    "figure_count": 0
  }
}