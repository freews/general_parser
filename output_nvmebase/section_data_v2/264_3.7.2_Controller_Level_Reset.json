{
  "section_index": 264,
  "section_id": "3.7.2",
  "title": "3.7.2 Controller Level Reset",
  "level": 3,
  "pages": {
    "start": 144,
    "end": 145,
    "count": 2
  },
  "content": {
    "text": "The following methods initiate a Controller Level Reset (CLR):\n•\nNVM Subsystem Reset;\n•\nController Reset (i.e., the host writes the CC property to clear the CC.EN bit from ‘1’ to ‘0’);\n•\nCross-Controller Reset command (refer to section 5.4.3); and\n•\nTransport specific reset types (refer to the applicable NVMe Transport binding specification), if any.\nA CLR consists of the following actions:\n•\nThe controller stops processing any outstanding Admin or I/O commands;\n•\nAll I/O Submission Queues are deleted;\n•\nAll I/O Completion Queues are deleted;\n•\nThe controller is brought to an idle state. When this is complete, the CSTS.RDY bit is cleared to\n‘0’; and\n•\nAll NVMe controller properties defined in either section 3.1.4 or the applicable NVMe Transport\nbinding specification and all internal controller state are reset, with the following exceptions:\nfor memory-based controllers:\n▪\nthe following are not reset as part of a CLR initiated by a Controller Reset:\n•\nAdmin Queue properties (i.e., AQA, ASQ, and ACQ);\n•\nPersistent Memory Region properties (i.e., PMRCAP, PMRCTL, PMRSTS, PMREBS,\nPMRSWTP, PMRMSCU, and PMRMSCL); and\n•\nThe Controller Memory Buffer Memory Space Control property (CMBMSC);\nand\n▪\nthe following are not reset as part of a CLR initiated by a Function Level Reset:\n•\nthe Controller Memory Buffer Memory Space Control property (CMBMSC);\nand\nfor message-based controllers:\n▪\nthere are no exceptions.\nFor all CLRs except those initiated by a Controller Reset, the controller properties defined by the transport\n(e.g., the PCIe registers defined by the PCIe Base Specification) are reset as defined by the applicable\nNVMe Transport binding specification (e.g., refer the NVMe over PCIe Transport Specification).\nUpon completion of a CLR, if the media is not usable and an NVM Subsystem Shutdown that includes the\ncontroller is neither reported as in progress nor reported as complete (i.e., the CSTS.ST bit is cleared to ‘0’\nor the CSTS.SHST field is cleared to 00b), then the controller is permitted to initialize the media for use.\nTo continue after a CLR, the host should:\n•\nupdate transport specific state and controller property state as appropriate;\n•\nset the CC.EN bit to ‘1’;\n•\nwait for the CSTS.RDY bit to be set to ‘1’;\n•\nconfigure the controller using Admin commands as needed;\n•\ncreate I/O Completion Queues and I/O Submission Queues as needed; and\n•\nproceed with normal I/O operations.\nNote that all CLRs except those initiated by a Controller Reset result in the controller immediately losing\ncommunication with the host. In all these cases, the controller is unable to indicate any aborts or update\nany completion queue entries.\nFor a message-based controller, if the CC.EN bit transitions to ‘0’ due to a Controller Reset while controller\nshutdown processing is either in progress or reported as complete (i.e., the CSTS.ST bit is cleared to ‘0’\nand the CSTS.SHST field is set to either 01b or 10b), then the association between the host and that\ncontroller shall be preserved for at least 2 minutes (i.e., the Admin Queue shall remain connected). After\nthis time, the association may be removed if that controller has not been re-enabled. The requirements in\nthis paragraph do not apply to NVM Subsystem Shutdown processing (i.e., these requirements do not apply\nif the CSTS.ST bit is set to ‘1’).\nAfter a Controller Reset, a message-based controller continues to process Fabrics commands (e.g.\nProperty Get, Property Set) (refer to section 3.3.2.3).\nIf the host is no longer able to communicate with the controller before that host receives either:\n•\ncompletions for all outstanding commands submitted to that controller (refer to section 3.4.5); or\n•\na CSTS.RDY bit value cleared to ‘0’,\nthen it is strongly recommended that the host take the steps described in section 9.6 to avoid possible data\ncorruption caused by interaction between outstanding commands and subsequent commands submitted\nby that host to another controller.",
    "tables": [],
    "figures": []
  },
  "statistics": {
    "table_count": 0,
    "figure_count": 0
  }
}