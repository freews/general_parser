{
  "section_index": 156,
  "section_id": "3.1.3.3",
  "title": "3.1.3.3 Discovery Controller",
  "level": 4,
  "pages": {
    "start": 65,
    "end": 67,
    "count": 3
  },
  "content": {
    "text": "A Discovery controller is a controller used in NVMe over Fabrics. A Discovery controller enables a host to\ndiscover other NVM subsystems or other Discovery subsystems. A Discovery controller only implements\nfeatures related to Discovering other subsystems and does not implement I/O Queues, I/O commands, or\nexpose namespaces. The features supported by the Discovery controller are defined in section 3.1.3.6.\nIf the Discovery subsystem provides a unique Discovery Service NQN (i.e., the NVM Subsystem NVMe\nQualified Name (SUBNQN) field in that Discovery subsystem’s Identify Controller data structure contains a\nunique Discovery Service NQN value), then that Discovery subsystem shall support both the unique\nDiscovery\nService\nNQN\nand\nthe\nwell-known\nDiscovery\nService\nNQN\n(i.e.,\nnqn.2014-\n08.org.nvmexpress.discovery) being specified in the Connect command (refer to section 6.3) from the host.\nIf the Discovery subsystem does not provide a unique Discovery Service NQN (i.e., the SUBNQN field in\nthat Discovery subsystem’s Identify Controller data structure contains the well-known Discovery Service\nNQN), then that Discovery subsystem shall support the well-known Discovery Service NQN being specified\nin the Connect command from the host.\nIn the Connect command to a Discovery subsystem that provides a unique Discovery Service NQN, the\nhost may use either of the following:\n•\nthe well-known Discovery Service NQN; or\n•\nthe unique Discovery Service NQN of that Discovery subsystem.\nIn the Connect command to a Discovery subsystem that does not provide a unique Discovery Service NQN\nthe host uses the well-known Discovery Service NQN.\nThe method that a host uses to obtain the fabric information necessary to connect to a Discovery controller\nusing the well-known Discovery Service NQN or the unique NQN via the NVMe Transport may be:\na) implementation specific;\nb) fabric specific;\nc) known in advance (e.g., a well-known address);\nd) administratively configured; or\ne) for IP-based fabrics, Automated Discovery of Discovery Controllers for IP-based Fabrics (refer to\nsection 8.3.1) may be used.\nThe Discovery log page provided by a Discovery controller contains one or more entries. Each entry\nspecifies information necessary for the host to connect to an NVM subsystem. An entry may be associated\nwith an NVM subsystem that exposes namespaces or a referral to another Discovery Service. There are\nno ordering requirements for log page entries within the Discovery log page.\nDiscovery controller(s) may provide different log page contents depending on the Host NQN provided (e.g.,\ndifferent NVM subsystems may be accessible to different hosts). The set of Discovery Log Page Entries\nshould include all applicable addresses on the same fabric as the Discovery Service and may include\naddresses on other fabrics.\nDiscovery controllers that support explicit persistent connections shall support both the Asynchronous\nEvent Request command and the Keep Alive command (refer to sections 5.2.2 and 5.2.14 respectively). A\nhost requests an explicit persistent connection to a Discovery controller and Asynchronous Event\nNotifications from the Discovery controller on that persistent connection by specifying a non-zero Keep\nAlive Timer value in the Connect command. If the Connect command specifies a non-zero Keep Alive Timer\nvalue and the Discovery controller does not support Asynchronous Events, then the Discovery controller\nshall return a status value of Connect Invalid Parameters (refer to Figure 582) for the Connect command.\nDiscovery controllers shall indicate support for Discovery Log Change Notifications in the Identify Controller\ndata structure (refer to Figure 328).\nDiscovery controllers that do not support explicit persistent connections shall not support Keep Alive\ncommands and may use a fixed Discovery controller activity timeout value (e.g., 2 minutes). If no commands\nare received by such a Discovery controller within that time period, the controller may perform the actions\nfor Keep Alive Timer expiration defined in section 3.9.5.\nA Discovery controller shall not support the Disconnect command.\nA Discovery log page with multiple Discovery Log Page Entries for the same NVM subsystem indicates that\nthere are multiple fabric paths to the NVM subsystem, and/or that multiple static controllers may share a\nfabric path. The host may use this information to form multiple associations to controllers within an NVM\nsubsystem.\nMultiple Discovery Log Page Entries for the same NVM subsystem with different Port ID values indicates\nthat the resulting NVMe Transport connections are independent with respect to NVM subsystem port\nhardware failures. A host that uses a single association should pick a record to attach to an NVM\nsubsystem. A host that uses multiple associations should choose different ports.\nA transport specific method may exist to indicate changes to a Discovery controller.\nController IDs in the range FFF0h to FFFFh are not allocated as valid Controller IDs on completion of a\nConnect command, as described in section 6.3. Figure 27 defines these Controller IDs.\nThe Controller ID values returned in the Discovery Log Page Entries indicate whether an NVM subsystem\nsupports the dynamic or static controller model. The controller ID value of FFFFh is used for NVM\nsubsystems that support the dynamic controller model indicating that any available controller may be\nreturned. The Controller ID value of FFFEh is used for NVM subsystems that support the static controller\nmodel indicating that any available controller may be returned. An NVM subsystem supports the dynamic\ncontroller model if Discovery Log Page Entries use the Controller ID value of FFFFh. An NVM subsystem\nsupports the static controller model if Discovery Log Page Entries use a Controller ID value that is less than\nFFFFh. The Identify Controller data structure also indicates whether an NVM subsystem is dynamic or\nstatic.\nIf an NVM subsystem implements the dynamic controller model, then multiple Discovery Log Page Entries\n(refer to Figure 310) with the Controller ID set to FFFFh may be returned for that NVM subsystem (e.g., to\nindicate multiple NVM subsystem ports) in the Discovery log page. If an NVM subsystem implements the\nstatic controller model, then multiple Discovery Log Page Entries that indicate different Controller ID values\nmay be returned for that NVM subsystem in the Discovery log page. If an NVM subsystem that implements\nthe static controller model includes any Discovery Log Page Entries that indicate a Controller ID of FFFEh,\nthen the host should remember the Controller ID returned from the Fabrics Connect command and re-use\nthe allocated Controller ID for future associations to that particular controller.",
    "tables": [
      {
        "id": "table_67_216",
        "page": 67,
        "bbox": [
          115.0,
          216.0,
          881.0,
          380.0
        ],
        "image_path": "Table_3_1_3_3_Discovery_Controller.png",
        "title": "Table_3_1_3_3_Discovery_Controller",
        "table_md": "| Controller ID | Definition |\n|---|---|\n| FFF0h to FFFCh | Reserved. Use of this value in a Connect command results in a status code of Connect Invalid Parameters being returned, as described in section 6.3. |\n| FFFDh | This value in the Controller ID (CNTLID) field of the Registered Controller data structure or Registered Controller Extended data structure for a dispersed namespace indicates that the controller is not contained in the same participating NVM subsystem as the controller processing the command (refer to section 8.1.10.6). Use of this value in a Connect command results in a status code of Connect Invalid Parameters being returned, as described in section 6.3. |\n| FFFEh | This value is sent in a Connect command to specify that any available static controller is allowed to be allocated. |\n| FFFh | This value is sent in a Connect command to specify that any available dynamic controller is allowed to be allocated. |"
      }
    ],
    "figures": []
  },
  "statistics": {
    "table_count": 1,
    "figure_count": 0
  }
}