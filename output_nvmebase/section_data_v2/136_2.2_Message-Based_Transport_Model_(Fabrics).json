{
  "section_index": 136,
  "section_id": "2.2",
  "title": "2.2 Message-Based Transport Model (Fabrics)",
  "level": 2,
  "pages": {
    "start": 46,
    "end": 46,
    "count": 1
  },
  "content": {
    "text": "The message-based transport model used for NVMe over Fabrics has the following differences from the\nmemory-based transport model:\n•\nThere is a one-to-one mapping between I/O Submission Queues and I/O Completion Queues.\nNVMe over Fabrics does not support multiple I/O Submission Queues being mapped to a single\nI/O Completion Queue;\n•\nNVMe over Fabrics does not define an interrupt mechanism that allows a controller to generate a\nhost interrupt. It is the responsibility of the host fabric interface (e.g., Host Bus Adapter) to generate\nhost interrupts;\n•\nNVMe over Fabrics uses different mechanisms for I/O Submission Queue and I/O Completion\nQueue creation and deletion (refer to section 3.5);\n•\nNVMe over Fabrics does not support transferring metadata from a separate buffer (e.g., does not\nsupport the Metadata Pointer field, refer to Figure 92);\n•\nNVMe over Fabrics does not support PRPs but requires use of SGLs for Admin, I/O, and Fabrics\ncommands. This differs from the memory-based transport model where SGLs are not supported\nfor Admin commands and are optional for I/O commands;\n•\nNVMe over Fabrics does not support Completion Queue flow control (refer to section 3.3.1.2.1).\nThis requires that the host ensures there are available Completion Queue slots before submitting\nnew commands; and\n•\nNVMe over Fabrics allows Submission Queue flow control to be disabled if the host and controller\nagree to disable Submission Queue flow control. If Submission Queue flow control is disabled, the\nhost is required to ensure that there are available Submission Queue slots before submitting new\ncommands.",
    "tables": [],
    "figures": []
  },
  "statistics": {
    "table_count": 0,
    "figure_count": 0
  }
}