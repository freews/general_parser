{
  "section_index": 807,
  "section_id": "8.2.4",
  "title": "8.2.4 Persistent Memory Region",
  "level": 3,
  "pages": {
    "start": 684,
    "end": 686,
    "count": 3
  },
  "content": {
    "text": "The Persistent Memory Region (PMR) is an optional region of general purpose PCI Express read/write\npersistent memory that may be used for a variety of purposes. The controller indicates support for the PMR\nby setting the CAP.PMRS bit (refer to section 3.1.4.1) to ‘1’ and indicates whether the controller supports\ncommand data and metadata transfers to or from the PMR by setting support flags in the PMRCAP property.\nWhen command data and metadata transfers to or from the PMR are supported, all data and metadata\nassociated with a particular command shall be either entirely located in the PMR or outside the PMR.\nPMR reads and PMR writes are initiated either by PCIe read and write transactions or by a controller\nassociated with the PMR (i.e., a controller that is able to access the PMR using the controller address range\ninstead of PCIe, and the controller and the PMR are implemented in the same PCIe function).\nPCIe read and write transactions to the PMR use the PCIe address range of the PMR. The PCI Express\naddress range and size of the PMR is defined by the PCI Base Address Register (BAR) indicated by the\nPMRCAP.BIR field. The PMR consumes the entire address region exposed by the BAR and supports all\nthe required features of the PCI Express programming model (i.e., it in no way restricts what is otherwise\npermitted by PCI Express).\nThe controller uses the controller address range of the PMR to reference the PMR with addresses supplied\nby the host. The PCI Express address range and the controller address range of the PMR may differ, but\nboth ranges have the same size, and equivalent offsets within each range have a one-to-one\ncorrespondence. The host configures the controller address range of the PMR via the PMRMSCU and\nPMRMSCL properties.\nThe host enables the controller memory space of the PMR via the PMRMSCL.CMSE bit. When controller\nmemory space is enabled, if host supplies an address referencing the controller address range of the PMR,\nthen the controller directs memory read or write requests for this address to the PMR.\nWhen the controller memory space of the PMR is disabled, the controller does not consider any host-\nsupplied address to reference the controller address range of the PMR, and memory read and write\nrequests are directed elsewhere (e.g., to memory other than the PMR).\nThe contents of data written to the PMR while the PMR is ready persists across power cycles, Controller\nLevel Resets, and disabling of the PMR. The mechanism used to make a write to the PMR persistent is\nimplementation specific. For example, in one implementation this may mean that a write to non-volatile\nmemory has completed while in another implementation this may mean that the write has been stored in a\nnon-volatile write buffer and is written to non-volatile memory at some later point.\nA PMR implementation has a maximum sustained write throughput. The PMR implementation may also\nhave an optional write elasticity buffer used to buffer writes from PMR PCIe write requests. When the PMR\nsustained write throughput is less than the PCI Express link throughput, then such a write elasticity buffer\nallows PCIe write request burst throughput to exceed the PMR sustained write throughput without back\npressuring into the PCI Express fabric.\nThe time required to transfer data from the write elasticity buffer to non-volatile media is the amount of data\nwritten to the elasticity buffer divided by the maximum PMR sustained write throughput (refer to section\n3.1.4.26). The time to transfer the entire contents of the write elasticity buffer is the size of the PMR elasticity\nbuffer (refer to section 3.1.4.25) divided by the maximum PMR sustained write throughput. The host is\nrequired to account for any units differences in the PMR Elasticity Buffer Size Units field and the PMR\nSustained Write Throughput Units field.\nThe host enables the PMR by setting the PMRCTL.EN bit to ‘1’. Once enabled, the controller indicates that\nthe PMR is ready by clearing the PMRSTS.NRDY bit to ‘0’. It is not necessary to enable the controller to\nenable the PMR. Restoring and saving the contents of the PMR may take time to complete. When the host\nmodifies the value of the PMRCTL.EN bit, the host should wait for at least the time interval specified in the\nPMRCAP.PMRTO field for the PMRSTS.NRDY bit to reflect the change.\nWhen the PMR is not ready:\n•\nPCIe PMR reads complete successfully and return an undefined value; and\n•\nPCIe PMR writes complete successfully but do not update memory (i.e., the contents of the PMR\naddress written remains unchanged).\nThe undefined value returned by a PCIe PMR read following a sanitize operation is such that recovery of\nany previous user data from any cache or the non-volatile storage media is prohibitively difficult (i.e.,\ninfeasible for a given level of effort (refer to IEEE Std 2883)).\nWhen the PMR becomes read-only or unreliable, then a critical warning is reported in the SMART / Health\nInformation log page which may be used to trigger an NVMe interface asynchronous event. Since reporting\nof an asynchronous event may occur an unspecified amount of time after the PMR health status has\nchanged, the host should assume that all operations to the PMR have been affected since the last time\nnormal operation was reported in the PMRSTS.HSTS field.\nIf a controller processes a command specifying a data buffer in an associated PMR, then that controller\nmay be able to determine the health of the PMR and to access the PMR via the controller address range\nof the PMR. If that command specifies writing data to the PMR (e.g., the NVM Command Set Read\ncommand) and the controller detects that the data was not written (e.g., the Error (ERR) bit was set to ‘1’\nin the PMRSTS property), then the controller should abort that command with a status code of Data Transfer\nError.\nSuccessful completion of a command that specifies writing data to any PMR (associated or unassociated)\ndoes not indicate whether data was successfully written to that PMR. For each PMR to which such a\ncommand specifies writing data, the host should determine whether data was successfully written to that\nPMR by reading the PMRSTS property of the controller associated with that PMR. Failure to determine\nwhether data was successfully written to each PMR may result in data loss.\nPMRCAP.PMRWBM enumerates supported PMR write barrier mechanisms. At least one mechanism shall\nbe supported. An implementation may optionally support a mechanism where a PCI Express read of any\nsize to the PMR, including a “zero-length read,” ensures that all previous memory writes (i.e., Posted PCI\nExpress requests) to the PMR have completed and are persistent. An implementation may optionally\nsupport a write barrier mechanism that utilizes a read of the PMRSTS property. When supported, a read of\nthe PMRSTS property allows a host to:\n•\nensure that previously issued memory writes to the PMR have completed; and\n•\ndetermine whether the PMR updates associated with those writes have completed without error\nand are persistent.\nA PMR memory write error may be the result of a poisoned PCI Express TLP, an NVM subsystem internal\nerror, or a PMR health status issue.\nRegardless of the supported PMR write barrier mechanisms, a host may periodically read the PMRSTS\nproperty to ensure that reads to the PMR have returned valid data. For example, if a read to the PMRSTS\nproperty indicates that the PMR is operating normally is then followed by a series of reads, and finally a\nsecond read to the PMRSTS property that indicates the PMR is unreliable, then one or more of the reads\nbetween the two PMRSTS property reads may have returned invalid data. Such polling of the PMRSTS\nproperty may be unnecessary if the host handles poisoned TLPs and/or poisoned TLP error reporting is\nenabled.\nThe PMR write elasticity buffer size along with the PMR sustained write throughput allows a host to\ndetermine the amount of time for a read associated with a Persistent Memory Region write barrier\nmechanism to complete.\nSupport for PRPs, SGL Lists, Completion Queues, and Submission Queues in the Persistent Memory\nRegion is outside the scope of this specification. If the host attempts to use the Persistent Memory Region\nfor a PRP, SGL List, Completion Queue, or Submission Queue, the controller may abort the command with\na status code of Invalid Field in Command.",
    "tables": [],
    "figures": []
  },
  "statistics": {
    "table_count": 0,
    "figure_count": 0
  }
}