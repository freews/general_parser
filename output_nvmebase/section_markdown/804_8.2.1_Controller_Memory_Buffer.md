#### 8.2.1 Controller Memory Buffer

> **Section ID**: 8.2.1 | **Page**: 682-684

The Controller Memory Buffer (CMB) is a region of general purpose read/write memory on the controller.
The controller indicates support for the CMB by setting CAP.CMBS to ‘1’. The host indicates intent to use
the CMB by setting CMBMSC.CRE to ‘1’. If this bit is set to ‘1’, the controller indicates the properties of the
CMB via the CMBLOC and CMBSZ properties (refer to section 3.1.4).
The CMB may be used for a variety of purposes. The controller indicates which purposes the memory may
be used for by setting support flags in the CMBSZ property.
The CMB’s PCI Express address range is used for external memory read and write requests to the CMB.
The PCI Express base address of the CMB is defined by the PCI Base Address Register (BAR) indicated
by CMBLOC.BIR, and the offset indicated by CMBLOC.OFST. The size of the CMB is indicated by
CMBSZ.SZ.
The controller uses the CMB’s controller address range to reference CMB with addresses supplied by the
host. The PCI Express address range and the controller address range of the CMB may differ, but both
ranges have the same size, and equivalent offsets within each range have a one-to-one correspondence.
The host configures the controller address range via the CMBMSC property.
The host enables the CMB’s controller memory space via the CMBMSC.CMSE bit. When controller memory
space is enabled, if the host supplies an address referencing the CMB’s controller address range, then the
controller directs memory read or write requests for this address to the CMB.
When the CMB’s controller memory space is disabled, the controller does not consider any host-supplied
address to reference the CMB’s controller address range, and memory read and write requests are directed
elsewhere (e.g., to memory other than the CMB).
To prevent possible misdirection of the controller’s memory requests, before the host enables the CMB’s
controller memory space, the host should configure the CMB’s controller address range so that the
addresses do not overlap any address that the host intends to use for DMA.
In versions prior to NVM Express Base Specification, Revision 1.4, for a controller that supports the CMB,
the CMB’s controller address range is fixed to be equal to its PCI Express address range, and the CMB’s
controller memory space is always enabled whenever the controller is enabled. To prevent misdirection of
controller memory requests when such a controller is assigned to a virtual machine, the host (on the
hypervisor or host OS) should not enable translation of the CMB’s PCI Express address range and should
ensure that this address range does not overlap any range of pre-translated addresses that the virtual
machine may use for DMA.
A host may configure the CMBMSC property so that CMB operates when the controller is assigned to a
virtual machine that only supports NVM Express Base Specification, Revision 1.3 and earlier. To prevent
that virtual machine from unintentionally clearing the CMBMSC property to 0h, the contents of the CMBMSC
property are preserved across a Controller Level Reset (CLR) initiated by:
•
a Controller Reset; and
•
a Function Level Reset (refer to the NVMe over PCIe Transport Specification).
Submission Queues in host memory require the controller to perform a PCI Express read from host memory
in order to fetch the submission queue entries. Submission Queues in controller memory enable the host
to directly write the entire submission queue entry to the controller's internal memory space, avoiding one
read from the controller to the host. This approach reduces latency in command execution and improves
efficiency in a PCI Express fabric topology that may include multiple switches. Similarly, PRP Lists or SGLs
require separate fetches across the PCI Express fabric, which may be avoided by writing the PRP or SGL
to the Controller Memory Buffer. Completion Queues in the Controller Memory Buffer may be used for peer
to peer or other applications. For writes of small amounts of data, it may be advantageous to have the host
write the data and/or metadata to the Controller Memory Buffer rather than have the controller fetch it from
host memory.
The contents of the Controller Memory Buffer are undefined as the result of:
•
the CMBMSC.CMSE bit transitioning from ‘0’ to ‘1’;
•
a CLR initiated by a Controller Reset; or
•
a Function Level Reset.
The host should initialize any memory in the Controller Memory Buffer before being referenced (e.g., a
Completion Queue shall be initialized by the host in order for the Phase Tag to be used correctly (refer to
section 4.2.4)).
A CMB implementation has a maximum sustained write throughput. The CMB implementation may also
have an optional write elasticity buffer used to buffer writes from CMB PCIe write requests. When the CMB
sustained write throughput is less than the PCI Express link throughput, then such a write elasticity buffer
allows PCIe write request burst throughput to exceed the CMB sustained write throughput without back
pressuring into the PCI Express fabric.
The time required to transfer data from the write elasticity buffer to the CMB is the amount of data written
to the elasticity buffer divided by the maximum CMB sustained write throughput (refer to section 3.1.4.19).
The time to transfer the entire contents of the write elasticity buffer is the size of the CMB elasticity buffer
(refer to section 3.1.4.18) divided by the maximum CMB sustained write throughput. The host is required
to account for any units differences in the CMB Elasticity Buffer Size Units field and the CMB Sustained
Write Throughput Units field.
A controller memory-based queue is used in the same manner as a host memory-based queue – the
difference is the memory address used is located within the controller’s own memory rather than in the host
memory. The Admin or I/O Queues may be placed in the Controller Memory Buffer. If the
CMBLOC.CQMMS bit (refer to Figure 47) is cleared to ‘0’, then for a particular queue, all memory
associated with it shall reside in either the Controller Memory Buffer or outside the Controller Memory
Buffer.
If the CMBLOC.CQPDS bit (refer to Figure 47) is cleared to ‘0’, then for all queues in the Controller Memory
Buffer, the queue shall be physically contiguous.
The controller may support PRP Lists and SGLs in the Controller Memory Buffer. If the CMBLOC.CDPMLS
bit (refer to Figure 47) is cleared to ‘0’, then for a particular PRP List or SGL associated with a single
command, all memory containing the PRP List or SGL shall be either entirely located in the Controller
Memory Buffer or entirely located outside the Controller Memory Buffer.
PRP Lists and SGLs associated with a command may be placed in the Controller Memory Buffer if that
command is present in a Submission Queue in the Controller Memory Buffer. If:
a) CMBLOC.CDPCILS bit (refer to Figure 47) is cleared to ‘0’; and
b) a command is not present in a Submission Queue in the Controller Memory Buffer,
then the PRP Lists and SGLs associated with that command shall not be placed in the Controller Memory
Buffer.
The controller may support data and metadata in the Controller Memory Buffer. If the CMBLOC.CDMMMS
bit (refer to Figure 47) is cleared to ‘0’, then all data and metadata, if any, associated with a particular
command shall be either entirely located in the Controller Memory Buffer or entirely located outside the
Controller Memory Buffer.
If the requirements for the Controller Memory Buffer use are violated by the host, the controller shall abort
the associated command with a status code of Invalid Use of Controller Memory Buffer.
The address region allocated for the CMB shall be 4 KiB aligned. It is recommended that a controller
allocate the CMB on an 8 KiB boundary. The controller shall support burst transactions up to the maximum
payload size, support byte enables, and arbitrary byte alignment. The host shall ensure that all writes to the
CMB that are needed for a command have been sent before updating the SQ Tail doorbell property. The
Memory Write Request to the SQ Tail doorbell property shall not have the Relaxed Ordering bit set to ‘1’
(refer to the PCI Express Base Specification), to ensure that prior writes to the CMB have completed.
