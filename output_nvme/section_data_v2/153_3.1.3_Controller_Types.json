{
  "section_index": 153,
  "section_id": "3.1.3",
  "title": "3.1.3 Controller Types",
  "level": 3,
  "pages": {
    "start": 62,
    "end": 63,
    "count": 2
  },
  "content": {
    "text": "As shown in Figure 23Figure 23, there are three types of controllers. An I/O controller (refer to section\n3.1.3.1) is a controller that supports commands that provide access to user data stored on an NVM\nsubsystem’s non-volatile storage medium and may support commands that provide management\ncapabilities. An Administrative controller (refer to section 3.1.3.2) is a controller that supports commands\nthat provide management capabilities, but does not support I/O commands that access to user data stored\non an NVM subsystem’s non-volatile storage medium. A Discovery controller (refer to section 3.1.3.3) is a\ncontroller used in NVMe over Fabrics to provide access to a Discovery log page.\nThe Controller Type (CNTRLTYPE) field in the Identify Controller data structure indicates a controller’s\ntype. Regardless of controller type, all controllers implement one Admin Submission Queue and one Admin\nCompletion Queue. Depending on the controller type, a controller may also support one or more I/O\nSubmission Queues and I/O Completion Queues.\nWhen using a memory-based transport implementation (e.g., PCIe), a host submits commands to a\ncontroller through pre-allocated Submission Queues. A controller is alerted to newly submitted commands\nthrough SQ Tail Doorbell register (refer to the NVMe over PCIe Transport Specification) writes. The\ndifference between the previous doorbell register value and the current register write indicates the number\nof commands that were submitted.\nA controller fetches commands from the Submission Queue(s) and processes them. Except for fused\noperations, there are no ordering restrictions for processing of commands within or across Submission\nQueues (i.e., a controller may arbitrarily order the processing of commands that have been fetched). Data\nassociated with the processing of a command may or may not be committed to the NVM subsystem non-\nvolatile storage medium in the order that commands are submitted. If a host has ordering requirements for\nthe processing of commands, then that host is responsible for enforcing the ordering requirements.\nA host submits commands of higher priorities to the appropriate Submission Queues. Priority is associated\nwith the Submission Queue itself, thus the priority of the command is based on the Submission Queue to\nwhich that command was submitted. The controller arbitrates across the Submission Queues based on\nfairness and priority according to the arbitration scheme specified in section 3.4.4.\nUpon completion of the command execution by the NVM subsystem, the controller presents completion\nqueue entries to the host through the appropriate Completion Queues. Transport specific methods (e.g.,\nPCIe interrupts) are used to notify the host of completion queue entries to process (refer to the applicable\nNVM Express Transport specification).\nThere are no ordering restrictions for completions to the host. Each completion queue entry identifies the\nSubmission Queue Identifier and Command Identifier of the associated command. A host uses this\ninformation to correlate the completions with the commands submitted to the Submission Queue(s).\nA host is responsible for creating I/O Submission Queues and I/O Completion Queues prior to using those\nqueue pairs to submit commands to the controller. I/O Submission Queues and I/O Completion Queues\nare created using the Create I/O Submission Queue command (refer to section 5.3.2) and the Create I/O\nCompletion Queue command (refer to section 5.3.1).",
    "tables": [],
    "figures": []
  },
  "statistics": {
    "table_count": 0,
    "figure_count": 0
  }
}