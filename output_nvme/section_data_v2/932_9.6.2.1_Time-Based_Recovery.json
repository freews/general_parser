{
  "section_index": 932,
  "section_id": "9.6.2.1",
  "title": "9.6.2.1 Time-Based Recovery",
  "level": 4,
  "pages": {
    "start": 768,
    "end": 769,
    "count": 2
  },
  "content": {
    "text": "For Time-Based Recovery, the host performs the following steps:\n1. For message-based transports, terminate the association and the associated transport\nconnections. This step is skipped for memory-based transports.\n2. Determine that the controller has detected a loss of communication using at least one of the\nfollowing methods:\na. If the controller uses Command Based Keep Alive (refer to section 3.9.3.1), wait at least\nuntil 2 * KATT (refer to section 3.9) from the time the host submitted the most recent Keep\nAlive Command to the controller.\nb. If the controller uses Traffic Based Keep Alive (refer to section 3.9.4.1), wait at least until\n3 * KATT from the time the host submitted the most recent command to the controller.\nc. If another controller of the same NVM subsystem supports the Cross-Controller Reset log\npage (refer to section 5.2.12.3.1) and the host has initiated Cross-Controller Reset\nRecovery for this controller via that other controller, read the Cross-Controller Reset log\npage on that other controller. Controller detection of a loss of communication is indicated\nby an entry, if any, in that log page that contains:\ni.\nthe controller ID of this controller;\nii.\nthe value of the Controller Instance Uniquifer (CIU) field that is the same as the\nvalue of CIU field for the Identify Controller data structure for this controller;\niii.\nthe Cross-Controller Reset Status field with a value of Failed; and\niv.\nthe Controller Level Reset Initiated bit set to ‘1’.\nd. If another controller of the same NVM subsystem supports the Lost Host Communication\nlog page (refer to section 5.2.12.3.2), read the Lost Host Communication log page on that\nother controller. Controller detection of loss of communication is indicated by an entry, if\nany, in that log page that contains the controller ID of this controller and the value of the\nCIU field that is the same as the value of the CIU field in the Identify Controller data\nstructure for this controller.\ne. Receive a transport-specific notification for determining that the controller has terminated\nan NVMe Transport connection or detected a loss of communication (e.g., a fabric\nnotification or a PCIe surprise link down error notification for a PCIe link that directly\nconnects a host to an NVM subsystem (e.g., an SSD)).\n3. Wait for additional sufficient time to ensure that the controller has stopped processing commands\nusing one of the following:\na. If the CQT field (refer to Figure 328) is non-zero, wait for the amount of time indicated in\nthe CQT field to elapse; or\nb. If the CQT field is cleared to 0h, wait for an implementation specific amount of time (e.g.,\n10 seconds). The host should allow this value to be administratively configured.\nThe specification of the times to wait to ensure that the controller has detected a Keep Alive Timeout\ndescribed in this section (i.e., 2 * KATT and 3 * KATT) assumes that the transport delays any command by\nat most one KATT. Once the last command is fetched by the controller, the controller is required to detect\na Keep Alive Timeout after at most a further 1 * KATT for Command Based Keep Alive and at most 2 *\nKATT for Traffic Based Keep Alive (refer to Figure 90). The sum of the two delays (i.e., the transport delay\nand the delay to detect the Keep Alive timeout) is 2 * KATT for Command Based Keep Alive and 3 * KATT\nfor Traffic Based Keep Alive.",
    "tables": [],
    "figures": []
  },
  "statistics": {
    "table_count": 0,
    "figure_count": 0
  }
}