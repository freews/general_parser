{
  "section_index": 524,
  "section_id": "5.2.26.1.24.1.2",
  "title": "5.2.26.1.24.1.2 Programmable Key Authentication",
  "level": 7,
  "pages": {
    "start": 449,
    "end": 449,
    "count": 1
  },
  "content": {
    "text": "Programmable Key Authentication (refer to the PKAS bit in Figure 285) provides the means to unfreeze a\ncurrently frozen personality using an HMAC that is calculated using a key that is derived from a host-\nprogrammable key (i.e., Derived HMAC Key (DHK)) as described in section 8.1.6.3.1. The DHK is only able\nto be programmed in the NVM subsystem if there is no DHK programmed. If there is a DHK programmed,\nthen that DHK is able to be purged by submitting a Set Features command that specifies the Manufacturing\nDefault Personality (refer to section 5.2.26.1.24.2). If a personality supports Programmable Key\nAuthentication and:\n•\na DHK has not been programmed, then that personality is able to be frozen, but not unfrozen; or\n•\na DHK has been programmed, then that personality is able to be frozen and unfrozen.\nProtecting a frozen personality from being unfrozen, unless authenticated by the DHK, is enabled by\nprogramming a DHK. The programming of the DHK (refer to section 8.1.6.3) should be done in a secure\nenvironment (e.g., as part of the manufacturing process).\nThe DHK is utilized to sign security personality authenticated requests (refer to section 8.1.6.2.2) sent to\nthe controller using a Hash-based Message Authentication Code (HMAC) generated according to the CDP\nAuthentication Algorithm specified by the host and supported by the controller (refer to the CDPALG field\nin Figure 328).\nUse of a random number (i.e., random nonce) provides additional protection against replay of authenticated\nrequests where authenticated requests are recorded and played back later by an attacker (refer to section\n8.1.1.1).",
    "tables": [],
    "figures": []
  },
  "statistics": {
    "table_count": 0,
    "figure_count": 0
  }
}