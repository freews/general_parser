{
  "section_index": 548,
  "section_id": "5.2.26.2.4",
  "title": "5.2.26.2.4 Host Memory Buffer (Feature Identifier 0Dh)",
  "level": 5,
  "pages": {
    "start": 469,
    "end": 472,
    "count": 4
  },
  "content": {
    "text": "This Feature controls use of the Host Memory Buffer by the controller. The attributes are specified in\nCommand Dword 11, Command Dword 12, Command Dword 13, Command Dword 14, and Command\nDword 15.\nThe Host Memory Buffer feature provides a mechanism for the host to allocate a portion of host memory\nfor the exclusive use of the controller. After a successful completion of a Set Features command enabling\nthe host memory buffer, the host shall not write to:\na) The Host Memory Descriptor List (refer to Figure 481); and\nb) the associated host memory region (i.e., the memory regions described by the Host Memory\nDescriptor List),\nuntil the host memory buffer has been disabled.\nIf the host memory buffer is enabled, then a Set Features command to enable the host memory buffer (i.e.,\nthe EHM bit (refer to Figure 476) set to ‘1’) shall abort with a status code of Command Sequence Error.\nIf the host memory buffer is not enabled, then a Set Features command to disable the host memory buffer\n(i.e., the EHM bit (refer to Figure 476) cleared to ‘0’) shall succeed without taking any action.\nAfter a successful completion of a Set Features command that disables the host memory buffer, the\ncontroller shall not access any data in the host memory buffer until the host memory buffer has been\nenabled. The controller should retrieve any necessary data from the host memory buffer in use before\nposting the completion queue entry for the Set Features command that disables the host memory buffer.\nPosting of the completion queue entry for the Set Features command that disables the host memory buffer\nacknowledges that it is safe for the host to modify the host memory buffer contents. Refer to section 8.2.3.\nA host is able to restrict access to the host memory buffer (HMB) while the controller is in a non-operational\npower state that was configured by the host (refer to section 5.2.26.1.2). If this HMB non-operational power\nstate access restriction is enabled by the host (refer to Figure 476) and the host configures a non-\noperational power state, then the controller does not access the HMB until the controller transitions to an\noperational power state except for HMB access required to process Admin commands and background\noperations initiated by Admin commands. Enabling or disabling Non-Operational Power State Permissive\nMode (refer to section 5.2.26.1.10) shall have no effect on HMB non-operational power state access\nrestriction.\nEnabling or disabling HMB non-operational power state access restriction should not affect the Entry\nLatency (ENLAT) for non-operational power states (refer to section 8.1.18) that are reported in the power\nstate descriptors in Identify Controller data structure (e.g., if HMB non-operational power state access\nrestriction is enabled, the controller may consume additional time beyond the applicable Entry Latency\nvalue in order to retrieve necessary data from the HMB before the controller transitions to a non-operational\npower state).\nIf HMB non-operational power state access restriction is enabled and the controller autonomously\ntransitions from an operational power state to a non-operational power state, then HMB access by the\ncontroller is not restricted and that access should be minimized (e.g., access ceases as soon as possible\nafter that transition and does not resume until after the controller transitions to an operational power state).\nIf HMB non-operational power state access restriction is enabled and the host configures a non-operational\npower state while the controller is in a non-operational power state, then HMB access by the controller is\nrestricted.\nIf a Get Features command is issued for this Feature, then the completion queue entry indicates whether\nHMB non-operational power state access restriction is enabled and whether HMB non-operational power\nstate access restriction is currently restricting controller access to the HMB (refer to Figure 483).\nThe Host Memory Descriptor List Address (HMDLLA/HMDLUA) specifies the address of a physically\ncontiguous data structure in host memory that describes the address and length pairs of the Host Memory\nBuffer. The number of address and length pairs is specified in the Host Memory Descriptor List Entry Count\nin Figure 480. The Host Memory Descriptor List is described in Figure 481.\nIf the host specifies the Host Memory Descriptor List Entry Count field cleared to 0h, then the controller\nshall abort the command with a status code of Invalid Field in Command.\nEach Host Memory Buffer Descriptor Entry shall describe a host memory address in memory page size\nunits and the number of contiguous memory page size units associated with the host address.\nIf a Get Features command is issued for this Feature, the attributes specified in Figure 483 are returned in\nDword 0 of the completion queue entry and the Host Memory Buffer Attributes data structure, whose\nstructure is defined in Figure 484, is returned in the data buffer for that command.",
    "tables": [
      {
        "id": "table_470_505",
        "page": 470,
        "bbox": [
          115.0,
          505.0,
          882.0,
          837.0
        ],
        "table_md": "| Description | Description |\n| :--- | :--- |\n| Host Memory Descriptor List Lower Address (HMDLLA): This field specifies the least significant 32 bits of the physical location of the Host Memory Descriptor List (refer to Figure 481) for the Host Memory Buffer. | |\n| Host Memory Descriptor List Upper Address (HMDLUA): This field specifies the most significant 32 bits of the physical location of the Host Memory Descriptor List for the Host Memory Buffer. | |\n| Host Memory Descriptor List Entry Count (HMDLEC): This field specifies the number of entries in the Host Memory Buffer Descriptor List. | |\n| Host Memory Buffer Descriptor Entry 0: This field is the first Host Memory Buffer Descriptor (refer to Figure 482) in the list, if any. | |\n| Host Memory Buffer Descriptor Entry 1: This field is the second Host Memory Buffer Descriptor in the list, if any. | |\n| Host Memory Buffer Descriptor Entry n: This field is the last Host Memory Buffer Descriptor in the list, if any. | |\n| Buffer Size (BSIZE): Indicates the number of contiguous memory page size (CC.MPS) units for this descriptor. If this field is cleared to 0h, then the controller shall ignore this descriptor. | |\n| Buffer Address (BADD): Indicates the host memory address for this descriptor aligned to the memory page size (CC.MPS). The least significant bits (n:0) of this field indicate the offset within the memory page is 0h (e.g., if the memory page size is 4 KiB, then bits 11:00 shall be 0h; if the memory page size is 8 KiB, then bits 12:00 shall be 0h). | |\n| | |\n| | |\n| | |\n| | |\n| | |\n| | |\n| | |\n| | |\n| | |\n| |"
      },
      {
        "id": "table_471_128",
        "page": 471,
        "bbox": [
          115.0,
          128.0,
          881.0,
          218.0
        ],
        "table_md": "(Continuation of Untitled Table - see first part)"
      },
      {
        "id": "table_471_264",
        "page": 471,
        "bbox": [
          115.0,
          264.0,
          881.0,
          307.0
        ],
        "table_md": "(Continuation of Untitled Table - see first part)"
      },
      {
        "id": "table_471_353",
        "page": 471,
        "bbox": [
          115.0,
          353.0,
          881.0,
          444.0
        ],
        "table_md": "(Continuation of Untitled Table - see first part)"
      },
      {
        "id": "table_471_489",
        "page": 471,
        "bbox": [
          115.0,
          489.0,
          881.0,
          533.0
        ],
        "table_md": "(Continuation of Untitled Table - see first part)"
      },
      {
        "id": "table_471_642",
        "page": 471,
        "bbox": [
          115.0,
          642.0,
          881.0,
          687.0
        ],
        "table_md": "(Continuation of Untitled Table - see first part)"
      },
      {
        "id": "table_471_769",
        "page": 471,
        "bbox": [
          115.0,
          769.0,
          881.0,
          895.0
        ],
        "table_md": "(Continuation of Untitled Table - see first part)"
      },
      {
        "id": "table_472_156",
        "page": 472,
        "bbox": [
          114.0,
          156.0,
          883.0,
          266.0
        ],
        "table_md": "(Continuation of Untitled Table - see first part)"
      },
      {
        "id": "table_472_362",
        "page": 472,
        "bbox": [
          114.0,
          362.0,
          881.0,
          578.0
        ],
        "table_md": "(Continuation of Untitled Table - see first part)"
      },
      {
        "id": "table_472_624",
        "page": 472,
        "bbox": [
          114.0,
          624.0,
          881.0,
          814.0
        ],
        "table_md": "(Continuation of Untitled Table - see first part)"
      }
    ],
    "figures": []
  },
  "statistics": {
    "table_count": 10,
    "figure_count": 0
  }
}